/**

\page premise_and_principle Premise and Principle

When programming with this library, there is some premise and principle you should noticed.

\section premise_and_principle__exception_is_error Exception is Error

The most crucial spot of this library is <B>"Exception is Error"</B>.
When some functions throw exception, it should cause program paniked, rather than recover from it.
This is inspired from Rust, and also the compromise with STL.

Most functions this library provided has Rust-Result-like return value.
It means that programmer can handle error correctly.
However, this library is based on STL, another library that may throw C++ exception to indicate error.
We can not control this behavior of STL, so I forcely apply this rule.

\section premise_and_principle__os_encoding OS Encoding

This library has special treat with Windows to make it works on Windows.
However, for other operating system, it do not have too much care.
We brutally make a premise that other operating systems are UNIX-liked and use UTF8 as its encoding.

\section premise_and_principle__string_encoding String Encoding

Before using this library, you should know the encoding strategy of this library first.
In short words, this library use UTF8 encoding everywhere except some special cases list following (not all).

\li Traditional format function in yycc::string::op.
Traditional format function provide some overloads for ordinary string formatting.
That's because this feature is so common to use in some cases.
\li The message of Rust panic in yycc::panic.
Due to the limitation of \c std::format, we only can use ordinary string as its message content.
\li The message of standard library exception.
For the compatibility with C++ standard library exception,
we only can use ordinary string as the message of exception.

\section premise_and_principle__cmake All in CMake

Since YYCC 2.0 version, we do not provide MSVC install layout.
Any projects use this project should use CMake or CMake-compatible software as its build system.

The reason why we make this decision is that some essential contents are written in CMake files.
For example, some environment detection macros and Windows environment patches.
If you do not use CMake, these contents will not be presented in project and cause bad behavior when using this project.

*/
