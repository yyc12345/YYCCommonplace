#pragma once
#include "../../macro/stl_detector.hpp"

#if defined(YYCC_STL_CLANGSTL)

/**
 * @private
 * @file This is the polyfill for LLVM libcxx std::stacktrace.
 * This should be removed once libcxx provide it.
 * This polyfill is generated by AI.
 */

#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <memory>
#include <algorithm>

namespace std {

// 空实现的stacktrace_entry
class stacktrace_entry {
public:
    constexpr stacktrace_entry() noexcept = default;
    constexpr stacktrace_entry(const stacktrace_entry&) noexcept = default;
    stacktrace_entry& operator=(const stacktrace_entry&) noexcept = default;
    
    constexpr explicit operator bool() const noexcept { return false; }
    
    string description() const { return ""; }
    
    constexpr void* native_handle() const noexcept { return nullptr; }
    
private:
    // 使用void*作为占位符
    void* _handle = nullptr;
};

// 比较运算符
constexpr bool operator==(const stacktrace_entry&, const stacktrace_entry&) noexcept {
    return true;
}

constexpr bool operator!=(const stacktrace_entry&, const stacktrace_entry&) noexcept {
    return false;
}

constexpr bool operator<(const stacktrace_entry&, const stacktrace_entry&) noexcept {
    return false;
}

constexpr bool operator<=(const stacktrace_entry&, const stacktrace_entry&) noexcept {
    return true;
}

constexpr bool operator>(const stacktrace_entry&, const stacktrace_entry&) noexcept {
    return false;
}

constexpr bool operator>=(const stacktrace_entry&, const stacktrace_entry&) noexcept {
    return true;
}

// 流输出运算符
template<class charT, class traits>
basic_ostream<charT, traits>& operator<<(
    basic_ostream<charT, traits>& os, const stacktrace_entry&) {
    return os << basic_string<charT, traits>("<stacktrace not supported>");
}

// 空实现的stacktrace类
class stacktrace {
public:
    using value_type = stacktrace_entry;
    using const_iterator = const stacktrace_entry*;
    using iterator = const_iterator;
    using reference = const stacktrace_entry&;
    using const_reference = const stacktrace_entry&;
    using difference_type = ptrdiff_t;
    using size_type = size_t;

    // 构造和析构
    constexpr stacktrace() noexcept = default;
    stacktrace(const stacktrace&) = default;
    stacktrace& operator=(const stacktrace&) = default;
    ~stacktrace() = default;

    // 始终返回空的stacktrace
    static stacktrace current(size_t = 0) noexcept {
        return stacktrace();
    }

    // 容量
    constexpr size_type size() const noexcept { return 0; }
    constexpr size_type max_size() const noexcept { return 0; }
    constexpr bool empty() const noexcept { return true; }

    // 元素访问
    const_reference operator[](size_type) const noexcept {
        static stacktrace_entry entry;
        return entry;
    }
    
    const_reference at(size_type) const {
        throw out_of_range("stacktrace is empty");
    }

    // 迭代器
    constexpr const_iterator begin() const noexcept { return nullptr; }
    constexpr const_iterator end() const noexcept { return nullptr; }
    constexpr const_iterator cbegin() const noexcept { return nullptr; }
    constexpr const_iterator cend() const noexcept { return nullptr; }

    // 比较
    friend bool operator==(const stacktrace&, const stacktrace&) noexcept {
        return true;
    }
    
    friend bool operator!=(const stacktrace&, const stacktrace&) noexcept {
        return false;
    }

private:
    // 无数据成员
};

// stacktrace的流输出
template<class charT, class traits>
basic_ostream<charT, traits>& operator<<(
    basic_ostream<charT, traits>& os, const stacktrace&) {
    return os << basic_string<charT, traits>("Stacktrace is not supported in this implementation");
}

// to_string函数
inline string to_string(const stacktrace_entry&) {
    return "";
}

inline string to_string(const stacktrace&) {
    return "stacktrace not supported";
}

} // namespace std

#endif
